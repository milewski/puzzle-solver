use num_traits::WrappingAdd;

static K: [u32; 64] = [
    0b01000010100010100010111110011000,
    0b01110001001101110100010010010001,
    0b10110101110000001111101111001111,
    0b11101001101101011101101110100101,
    0b00111001010101101100001001011011,
    0b01011001111100010001000111110001,
    0b10010010001111111000001010100100,
    0b10101011000111000101111011010101,
    0b11011000000001111010101010011000,
    0b00010010100000110101101100000001,
    0b00100100001100011000010110111110,
    0b01010101000011000111110111000011,
    0b01110010101111100101110101110100,
    0b10000000110111101011000111111110,
    0b10011011110111000000011010100111,
    0b11000001100110111111000101110100,
    0b11100100100110110110100111000001,
    0b11101111101111100100011110000110,
    0b00001111110000011001110111000110,
    0b00100100000011001010000111001100,
    0b00101101111010010010110001101111,
    0b01001010011101001000010010101010,
    0b01011100101100001010100111011100,
    0b01110110111110011000100011011010,
    0b10011000001111100101000101010010,
    0b10101000001100011100011001101101,
    0b10110000000000110010011111001000,
    0b10111111010110010111111111000111,
    0b11000110111000000000101111110011,
    0b11010101101001111001000101000111,
    0b00000110110010100110001101010001,
    0b00010100001010010010100101100111,
    0b00100111101101110000101010000101,
    0b00101110000110110010000100111000,
    0b01001101001011000110110111111100,
    0b01010011001110000000110100010011,
    0b01100101000010100111001101010100,
    0b01110110011010100000101010111011,
    0b10000001110000101100100100101110,
    0b10010010011100100010110010000101,
    0b10100010101111111110100010100001,
    0b10101000000110100110011001001011,
    0b11000010010010111000101101110000,
    0b11000111011011000101000110100011,
    0b11010001100100101110100000011001,
    0b11010110100110010000011000100100,
    0b11110100000011100011010110000101,
    0b00010000011010101010000001110000,
    0b00011001101001001100000100010110,
    0b00011110001101110110110000001000,
    0b00100111010010000111011101001100,
    0b00110100101100001011110010110101,
    0b00111001000111000000110010110011,
    0b01001110110110001010101001001010,
    0b01011011100111001100101001001111,
    0b01101000001011100110111111110011,
    0b01110100100011111000001011101110,
    0b01111000101001010110001101101111,
    0b10000100110010000111100000010100,
    0b10001100110001110000001000001000,
    0b10010000101111101111111111111010,
    0b10100100010100000110110011101011,
    0b10111110111110011010001111110111,
    0b11000110011100010111100011110010
];


static H: [u32; 8] = [
    0b01101010000010011110011001100111,
    0b10111011011001111010111010000101,
    0b00111100011011101111001101110010,
    0b10100101010011111111010100111010,
    0b01010001000011100101001001111111,
    0b10011011000001010110100010001100,
    0b00011111100000111101100110101011,
    0b01011011111000001100110100011001,
];

#[test]
fn sha256_test() {
    let result = do_sha256(&[
        0x02,
        0xc9, 0x49, 0x57, 0xfe, 0xef, 0xc3, 0xc4, 0x15, 0xef, 0xc3, 0x71, 0x71, 0x83, 0x36, 0x68, 0xa9,
        0xfe, 0xb3, 0x94, 0xa3, 0x09, 0x74, 0x01, 0xc0, 0x10, 0xc0, 0xed, 0x8b, 0xcd, 0x98, 0xaa, 0xb5
    ]);

    assert_eq!(result, [
        0x6b, 0x45, 0x93, 0xb4, 0xe8, 0x6b, 0x12, 0x44, 0x29, 0x9a, 0x58, 0x11, 0xc8, 0x31, 0x6e, 0x01,
        0xde, 0x7b, 0x04, 0x08, 0x72, 0xab, 0xcf, 0x65, 0xbc, 0x43, 0x72, 0x9d, 0x80, 0x1a, 0xca, 0x79
    ]);
}

// https://sha256algorithm.com/
#[inline]
pub fn do_sha256(bytes: &[u8; 33]) -> [u8; 32] {

    // 02c94957feefc3c415efc37171833668a9feb394a3097401c010c0ed8bcd98aab5
    // 6b4593b4e86b1244299a5811c8316e01de7b040872abcf65bc43729d801aca79

    // let key = BigUint::from_str_radix("02c94957feefc3c415efc37171833668a9feb394a3097401c010c0ed8bcd98aab5", 16).unwrap();

    let mut block: [u8; 64] = [0; 64];

    for (index, byte) in bytes.into_iter().enumerate() {
        block[index] = *byte
    }

    block[33] = 0b10000000;
    block[62] = 0b00000001;
    block[63] = 0b00001000;

    let mut w: [u32; 64] = [0; 64];

    // schedule[0] = (block[0] as u32) << 24 | (block[1] as u32) << 16 | (block[2] as u32) << 8 | block[3] as u32;
    w[0] = u32::from_be_bytes([block[0], block[1], block[2], block[3]]);
    w[1] = u32::from_be_bytes([block[4], block[5], block[6], block[7]]);
    w[2] = u32::from_be_bytes([block[8], block[9], block[10], block[11]]);
    w[3] = u32::from_be_bytes([block[12], block[13], block[14], block[15]]);
    w[4] = u32::from_be_bytes([block[16], block[17], block[18], block[19]]);
    w[5] = u32::from_be_bytes([block[20], block[21], block[22], block[23]]);
    w[6] = u32::from_be_bytes([block[24], block[25], block[26], block[27]]);
    w[7] = u32::from_be_bytes([block[28], block[29], block[30], block[31]]);
    // schedule[8] = u32::from_be_bytes([block[32], block[33], block[34], block[35]]);

    // schedule[15] = u32::from_be_bytes([block[60], block[61], block[62], block[63]]);

    w[8] = (block[32] as u32) << 24 | (block[33] as u32) << 16; // save 2 shifts
    w[15] = (block[62] as u32) << 8 | (block[63] as u32);       // save 2 shifts

    // step 2

    // let a0 = (w[1] << 7) | (w[1] >> 18) | (w[1] >> 3);
    // w[16] = w[0]

    // let a0 = ((w[1] >> 7) | (w[1] << (32 - 7))) ^ ((w[1] >> 18) | (w[1] << (32 - 18))) ^ (w[1] >> 3);
    // let a1 = ((w[14] >> 17) | (w[14] << (32 - 17))) ^ ((w[14] >> 19) | (w[14] << (32 - 19))) ^ (w[14] >> 10);
    //
    // w[16] = w[0] + a0 + w[9] + a1;

    for index in 16..64 {
        w[index] = rotate(&mut w, index - 15);
    }

    let mut a: u32 = H[0];
    let mut b: u32 = H[1];
    let mut c: u32 = H[2];
    let mut d: u32 = H[3];
    let mut e: u32 = H[4];
    let mut f: u32 = H[5];
    let mut g: u32 = H[6];
    let mut h: u32 = H[7];

    for index in 0..64 {
        let choice = (e & f) ^ (!e & g);
        let e0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
        let e1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
        let majority = (a & b) ^ (a & c) ^ (b & c);

        let temp1 = h.wrapping_add(e1).wrapping_add(choice).wrapping_add(K[index]).wrapping_add(w[index]);
        let temp2 = e0.wrapping_add(majority);

        h = g;
        g = f;
        f = e;
        e = d.wrapping_add(temp1);
        d = c;
        c = b;
        b = a;
        a = temp1.wrapping_add(temp2);
    }

    // 01101011010001011001001110110100
    // 01101011010001011001001110110100
    let a = a.wrapping_add(H[0]).to_be_bytes();
    let b = b.wrapping_add(H[1]).to_be_bytes();
    let c = c.wrapping_add(H[2]).to_be_bytes();
    let d = d.wrapping_add(H[3]).to_be_bytes();
    let e = e.wrapping_add(H[4]).to_be_bytes();
    let f = f.wrapping_add(H[5]).to_be_bytes();
    let g = g.wrapping_add(H[6]).to_be_bytes();
    let h = h.wrapping_add(H[7]).to_be_bytes();

    [
        a[0], a[1], a[2], a[3],
        b[0], b[1], b[2], b[3],
        c[0], c[1], c[2], c[3],
        d[0], d[1], d[2], d[3],
        e[0], e[1], e[2], e[3],
        f[0], f[1], f[2], f[3],
        g[0], g[1], g[2], g[3],
        h[0], h[1], h[2], h[3],
    ]

    // println!("{:032b}", a);
    // println!("{:02x} {:02x} {:02x} {:02x} {:02x} {:02x} {:02x} {:02x}", a, b, c, d, e, f, g, h);
}

#[inline]
fn rotate(w: &mut [u32; 64], index: usize) -> u32 {
    let offset_a = index;
    let offset_b = index + 14 - 1;

    let a0 = ((w[offset_a] >> 7) | (w[offset_a] << (32 - 7))) ^ ((w[offset_a] >> 18) | (w[offset_a] << (32 - 18))) ^ (w[offset_a] >> 3);
    let a1 = ((w[offset_b] >> 17) | (w[offset_b] << (32 - 17))) ^ ((w[offset_b] >> 19) | (w[offset_b] << (32 - 19))) ^ (w[offset_b] >> 10);

    w[offset_a - 1]
        .wrapping_add(a0)
        .wrapping_add(w[offset_a + 8])
        .wrapping_add(a1)
}